# Music Visualizer 구현 계획

## 1단계: 프로젝트 생성 및 기본 설정

- **목표:** Flutter 데스크톱 애플리케이션 프로젝트의 기본 구조를 설정하고, 필요한 라이브러리를 추가하며, 초기 화면 설정을 완료합니다.
- **세부 작업:**
    1.  `flutter create music_visualizer` 명령을 사용하여 신규 Flutter 프로젝트를 생성합니다. (Windows 데스크톱 지원 활성화)
    2.  `pubspec.yaml` 파일을 열어 다음 라이브러리를 `dependencies`에 추가합니다.
        - `mic_stream`: 실시간 마이크 입력을 위해 사용합니다.
        - `fftea`: 오디오 데이터의 주파수 분석(FFT)을 위해 사용합니다.
    3.  `main.dart` 파일을 수정하여 애플리케이션 창의 초기 크기를 1920x480으로 설정합니다.
    4.  기본적으로 생성된 카운터 예제 코드를 삭제하고, 깨끗한 상태의 `main.dart` 파일을 준비합니다.
- **완료 확인:**
    - 프로젝트가 성공적으로 생성되고, 데스크톱에서 실행되는지 확인합니다.
    - 1920x480 크기의 빈 창이 나타나는지 확인합니다.
- **Commit:**
    - `git add .`
    - `git commit -m "feat: Initialize Flutter project and set up basic configurations"`

---

## 2단계: 실시간 오디오 입력 구현

- **목표:** PC에 연결된 기본 마이크로부터 오디오 데이터를 실시간으로 수신하는 기능을 구현합니다.
- **세부 작업:**
    1.  마이크 권한을 요청하고 처리하는 로직을 추가합니다.
    2.  `mic_stream` 라이브러리를 사용하여 오디오 스트림 리스너를 초기화합니다.
    3.  오디오 스트림에서 데이터를 수신할 때마다 해당 데이터가 버퍼에 저장되는지 확인합니다.
    4.  (디버깅 목적) 수신된 오디오 데이터의 일부를 콘솔에 출력하여 데이터가 정상적으로 들어오는지 확인합니다.
- **완료 확인:**
    - 애플리케이션 실행 시 마이크 권한 요청이 정상적으로 처리됩니다.
    - 콘솔에 실시간 오디오 데이터(숫자 배열 형태)가 출력되는 것을 확인합니다.
- **Commit:**
    - `git add .`
    - `git commit -m "feat: Implement real-time audio input from microphone"`

---

## 3단계: 오디오 데이터 분석 기능 구현

- **목표:** 입력된 오디오 스트림을 분석하여 소리의 크기(데시벨)와 높낮이(음계)를 실시간으로 계산합니다.
- **세부 작업:**
    1.  **데시벨 계산:**
        - 오디오 데이터 청크(버퍼)의 RMS(Root Mean Square)를 계산하여 데시벨로 변환하는 함수를 작성합니다.
    2.  **음계 분석:**
        - `fftea` 라이브러리를 사용하여 오디오 데이터에 FFT(고속 푸리에 변환)를 적용합니다.
        - FFT 결과에서 가장 에너지가 높은 주파수(Dominant Frequency)를 찾습니다.
        - 미리 정의된 주파수-음계 매핑 테이블을 사용하여 해당 주파수에 가장 가까운 음계를 식별하는 함수를 작성합니다.
    3.  계산된 데시벨과 식별된 음계 값을 화면에 텍스트 형태로 출력하여 실시간으로 값이 변하는지 확인합니다.
- **완료 확인:**
    - 마이크에 소리를 입력했을 때 화면에 표시된 데시벨 값이 변동합니다.
    - 다른 높이의 소리(예: 허밍)를 냈을 때, 화면에 표시된 음계가 그에 맞게 변경되는 것을 확인합니다.
- **Commit:**
    - `git add .`
    - `git commit -m "feat: Implement audio analysis for decibel and pitch"`

---

## 4단계: 기본 시각화 구현

- **목표:** 분석된 오디오 데이터를 사용하여 간단한 시각적 요소를 화면에 렌더링합니다.
- **세부 작업:**
    1.  화면 전체를 차지하는 검은색 배경의 `StatefulWidget`을 생성합니다.
    2.  `CustomPainter`를 사용하여 캔버스에 그림을 그릴 준비를 합니다.
    3.  오디오 분석 모듈에서 계산된 데시벨 값을 `CustomPainter`에 전달합니다.
    4.  `paint` 메소드 내에서, 전달받은 데시벨 값에 따라 높이가 변하는 수직 막대(Bar)를 화면 중앙에 그립니다.
- **완료 확인:**
    - 애플리케이션 화면에 수직 막대가 표시됩니다.
    - 마이크에 입력되는 소리의 크기에 따라 막대의 높이가 실시간으로 오르내리는 것을 확인합니다.
- **Commit:**
    - `git add .`
    - `git commit -m "feat: Implement basic visualization with a decibel bar"`

---

## 5단계: 고급 시각화 효과 적용

- **목표:** 기본 시각화에 색상과 애니메이션을 추가하여 "화려한" 그래픽으로 발전시킵니다.
- **세부 작업:**
    1.  음계 분석 모듈에서 식별된 음계 값을 `CustomPainter`에 전달합니다.
    2.  음계에 따라 색상을 매핑하는 로직을 추가합니다. (예: C=빨강, D=주황, E=노랑...)
    3.  `paint` 메소드에서 현재 음계에 해당하는 색상으로 막대를 그립니다.
    4.  `AnimationController`를 사용하여 값의 변화(막대 높이, 색상 등)가 부드럽게 전환되도록 애니메이션을 적용합니다.
    5.  막대 그래프 대신 파티클 시스템이나 파형(Waveform) 등 다른 형태의 시각화 요소를 추가하는 것을 고려합니다. (이 단계에서는 막대 그래프에 효과를 집중)
    6.  네온(glow) 효과를 위해 `Paint` 객체의 `maskFilter` 속성을 `MaskFilter.blur`와 함께 사용합니다.
- **완료 확인:**
    - 시각화 막대의 색상이 실시간으로 입력되는 음계에 따라 변경됩니다.
    - 소리 크기가 변할 때 막대 높이가 딱딱하게 변하는 것이 아니라, 부드러운 애니메이션으로 조절됩니다.
- **Commit:**
    - `git add .`
    - `git commit -m "feat: Apply advanced visualization effects with color and animation"`

---

## 6단계: 전체 통합 및 성능 최적화

- **목표:** 모든 기능(입력, 분석, 시각화)을 안정적으로 통합하고, 실시간 성능을 보장합니다.
- **세부 작업:**
    1.  각 모듈 간의 데이터 흐름이 원활한지 최종적으로 점검합니다. (예: `Stream`과 `State` 관리)
    2.  Flutter DevTools의 성능 프로파일링 도구를 사용하여 CPU 및 GPU 사용량을 확인합니다.
    3.  불필요한 위젯 리빌드를 최소화하고, `const` 키워드를 적극적으로 사용하여 렌더링 성능을 최적화합니다.
    4.  오디오 버퍼 크기, FFT 계산 주기 등을 조절하여 분석의 정확도와 성능 사이의 균형을 맞춥니다.
- **완료 확인:**
    - 애플리케이션이 끊김 없이 최소 30 FPS 이상으로 동작하는 것을 확인합니다.
    - 장시간 실행해도 메모리 누수가 발생하지 않고 안정적으로 동작합니다.
- **Commit:**
    - `git add .`
    - `git commit -m "refactor: Integrate all modules and optimize performance"`

---

## 7단계: 최종 코드 검토 및 정리

- **목표:** 프로젝트의 코드 품질을 높이고, 유지보수가 용이하도록 코드를 정리합니다.
- **세부 작업:**
    1.  전체 코드 베이스를 검토하며 SOLID 원칙 및 Clean Architecture 원칙에 맞게 리팩토링합니다.
    2.  변수명, 함수명을 명확하게 수정하고, 하드코딩된 값(Magic Number)을 상수로 추출합니다.
    3.  복잡한 로직에 주석을 추가하여 다른 개발자가 쉽게 이해할 수 있도록 합니다.
    4.  사용하지 않는 코드를 제거하고, 파일 및 폴더 구조를 논리적으로 정리합니다.
- **완료 확인:**
    - 코드베이스가 잘 정리되어 있고, 팀의 코딩 컨벤션을 준수합니다.
    - 프로젝트 구조가 명확하여 새로운 기능을 추가하기 용이합니다.
- **Commit:**
    - `git add .`
    - `git commit -m "docs: Final code cleanup and review"` 